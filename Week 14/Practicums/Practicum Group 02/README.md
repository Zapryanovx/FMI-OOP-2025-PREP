# Практикум 14: Множествено наследяване. Дървовидни структури

## Задача 1: Ястия
Да се напише програма, която позволява създаване и работа с множество от ястия. За целта да се създаде клас ястие ```Dish```. Всяко ястие ```Dish``` се характеризира със:
- Списък от продукти ```ingredientsNames``` - всеки продукт се задава чрез неговото име с произволна дължина. Списъкът съдържа максимум 100 продукта;
- Време за приготвяне ```cookTime``` - измерва се в минути.
- - Да се реализира функция ```print```, която извежда информацията за едно ястие на екрана.

За целта на нашата задача различаваме два основни типа ястия: 
Ястие с месо ```MeatDish```: съдържа допълнителна член-данна месо ```meat```, която съдържа името на основния протеин в ястието. Член-данната meat може да приема една от следните стойности: “chicken”, “beef”, “pork”, “duck”. Да се реализира функция ```print```, която извежда собствените и наследените данни за ястието;

Ястие с морска храна ```SeafoodDish``` - съдържа допълнителна член-данна морска храна ```seafood```, която съдържа името на основния протеин в ястието. Член-данната ```seafood``` може да бъде име на риба или друг морски дар с произволна дължина. Валидация на стойността на член-данната не е необходима. Да се реализира функция ```print```, която извежда собствените и наследените данни за ястието.

Да се реализира клас ```SurfAndTurf```, представляващ ястие, което комбинира морски дарове и месо. Да се напише функция ```print```, която извежда цялата информация за ястието. 

Да се реализира главна функция, която:
- Създава обект от тип ```SurfAndTurf```,
- Създава указател към ```Dish``` и го свързва с динамично създаден обект ```MeatDish```.

## Задача 2: Tasks
Да се реализира абстрактен клас ```WorkItem```, който съдържа име на задача. Всяка задача се със следните операции:
- bool status(long now): Връща true, ако задачата е проключена към момента now (в unix time формат: милисекунди от 1 януари 1970г. до сега)  и false в противен случай
- void print(size_t level=0): Принтира съдържанието на задачата. Параметърът level показва нивото на влагане на задачата (или казано по друг начин: броят интервали преди притирания резултат)

Да се дефинира клас ```SingleTask```, наследник на ```WorkItem```. Клас ```SimpleTask``` да дефинира задача, имаща следните характеристики, задавани по време на конструиране на задачата:
- Начална дата (unix time)
- Продължителност (в милисекунди)

Да се дефинира клас ```TaskGroup```, наследник на ```WorkItem```. Обектите от клас ```TaskGroup``` да поддържат списък с произволни задачи (прости и групови). Груповата задача се счита за приключена, когато всички нейни подзадачи за приключени. Класът да реализира следните допълнително функцията addTask.

Да се реализира фунция bool allDone ([подходящ тип] tasks, int n, int now), която по масива tasks с n на брой произволни типове задачи проверява дали всяка от тях е приключена в момента now.

**Примерно принтиране на TaskGroup:**
```
GroupTask:
  Taks 1
  Task 2:
    Task 2.1
    Task 2.2
    Task 2.3
  Task3
```
## Задача 3: Йерархия от множества
Трябва да създадете дървовидна структура от множества. Тя се състои от следните класове:

- ```Set``` - базов абстрактен клас, представляващ множество. Има pure virtual функция ```bool accepts(unsigned int)```, която ще определя дали даден елемент е в множеството или не.
- ```SetByCriteria<T>``` - темплейтен наследник на ```Set```, който пази в себе си обект от шаблонен тип ```Т```. За този обект ще бъде подаван указател към функция или обект, държащ се като функция. Композираният обект ще ви се подава в конструктура (трябва да може да се приеме чрез копиране или чрез местене). Функцията ```accept()``` връща резултата от извикване на ```operator()``` от обекта ```T``` върху подаденото входно число.
- ```SetOperation``` - абстрактен наследник на ```Set```, който представлява контейнер за други ```Set```-ове. Има разписана само Big6 в себе си, а член-данните му са protected.
- ```UnionOfSets``` - наследник на ```SetOperation```, който в конструктура приема масив от указатели към други множества и ги запазва в себе си (чрез копиране или move). Предефинира функцията ```accept()```, като я извиква на елементите в себе си, а резултатът е конюнкция от резултатите.
- ```IntersectionOfSets``` - наследник на ```SetOperation```, който в конструктура приема масив от указатели към други множества и ги запазва в себе си (чрез копиране или move). Предефинира функцията ```accept()```, като я извиква на елементите в себе си, а резултатът е дизюнкция от резултатите.
